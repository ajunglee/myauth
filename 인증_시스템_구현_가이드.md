# Spring Boot JWT 인증 시스템 구현 가이드

## 목차
1. [개요](#1-개요)
2. [로그인/로그아웃의 개념](#2-로그인로그아웃의-개념)
3. [보안 전략](#3-보안-전략)
4. [기술 스택](#4-기술-스택)
5. [단계별 구현 가이드](#5-단계별-구현-가이드)
6. [API 엔드포인트 정리](#6-api-엔드포인트-정리)
7. [테스트 방법](#7-테스트-방법)

---

## 1. 개요

이 문서는 **Spring Boot 4.0**을 사용하여 JWT 기반의 안전한 인증 시스템을 구현하는 방법을 단계별로 설명합니다.

### 구현 기능
- ✅ 이메일/비밀번호 기반 회원가입
- ✅ 일반 로그인 (2가지 방식)
  - 직접 구현 (수동 검증)
  - Spring Security AuthenticationManager 사용 (권장)
- ✅ 카카오 OAuth 2.0 소셜 로그인
- ✅ JWT Access Token + Refresh Token
- ✅ 하이브리드 토큰 전송 (웹: HTTP-only 쿠키, 모바일: JSON)
- ✅ 로그아웃 (Refresh Token 무효화)
- ✅ 전역 예외 처리

---

## 2. 로그인/로그아웃의 개념

### 2.1 로그인이란?

**로그인(Login)**은 사용자가 자신의 신원을 증명하고 시스템에 접근 권한을 얻는 과정입니다.

#### 전통적인 세션 기반 로그인
```
1. 사용자가 이메일/비밀번호 입력
2. 서버가 검증 후 세션 생성
3. 세션 ID를 쿠키로 브라우저에 전송
4. 이후 요청마다 세션 ID를 함께 전송
5. 서버는 세션 저장소에서 사용자 정보 조회
```

**단점:**
- 서버에 세션 저장 공간 필요 (메모리/Redis)
- 서버가 여러 대일 경우 세션 동기화 필요
- 확장성(Scalability) 제한

#### JWT 기반 로그인 (이 프로젝트에서 사용)
```
1. 사용자가 이메일/비밀번호 입력
2. 서버가 검증 후 JWT 토큰 생성 (서버에 저장 안 함!)
3. 토큰을 클라이언트에 전송
4. 이후 요청마다 토큰을 함께 전송
5. 서버는 토큰의 서명을 검증하여 사용자 확인
```

**장점:**
- 서버가 상태를 저장하지 않음 (Stateless)
- 서버 확장이 쉬움
- 마이크로서비스 아키텍처에 적합

### 2.2 로그아웃이란?

**로그아웃(Logout)**은 사용자의 인증 상태를 종료하는 과정입니다.

#### JWT 기반 로그아웃의 문제
JWT는 서버에 저장되지 않기 때문에 "강제 만료"가 어렵습니다. 토큰이 만료 시간 전까지는 계속 유효합니다.

#### 해결 방법 (이 프로젝트에서 사용)
1. **Refresh Token을 DB에 저장**
   - Refresh Token만 DB의 `refresh_tokens` 테이블에 저장
   - 로그아웃 시 DB에서 삭제 (무효화)

2. **Access Token은 짧게, Refresh Token은 길게**
   - Access Token: 1시간 (서버에 저장 안 함)
   - Refresh Token: 7일 (DB에 저장)
   - Access Token이 탈취되어도 1시간 후 자동 만료

3. **로그아웃 흐름**
   ```
   1. 클라이언트가 /logout 호출
   2. 서버가 Refresh Token을 DB에서 삭제
   3. 클라이언트는 로컬에 저장된 토큰 삭제
   4. 이후 Access Token 갱신 불가 (Refresh Token이 없으므로)
   ```

---

## 3. 보안 전략

### 3.1 JWT (JSON Web Token)

#### Access Token
- **용도**: API 요청 시 사용자 인증
- **만료 시간**: 1시간 (짧게 설정)
- **저장 위치**:
  - 웹: 메모리 또는 로컬 스토리지
  - 모바일: 안전한 저장소
- **내용**:
  ```json
  {
    "sub": "user@example.com",  // 사용자 이메일
    "userId": 123,               // 사용자 ID
    "type": "access",            // 토큰 타입
    "iat": 1234567890,           // 발행 시간
    "exp": 1234571490            // 만료 시간
  }
  ```

#### Refresh Token
- **용도**: Access Token 갱신
- **만료 시간**: 7일 (길게 설정)
- **저장 위치**:
  - 웹: HTTP-only 쿠키 (JavaScript 접근 불가)
  - 모바일: 안전한 저장소
- **DB 저장**: `refresh_tokens` 테이블에 저장 (로그아웃 시 무효화 가능)

### 3.2 비밀번호 암호화

#### BCrypt 사용
```java
// 회원가입 시
String encodedPassword = passwordEncoder.encode("평문비밀번호");

// 로그인 시
boolean isValid = passwordEncoder.matches("입력된비밀번호", "저장된암호화비밀번호");
```

**특징:**
- 단방향 해시 (복호화 불가능)
- Salt 자동 생성 (같은 비밀번호라도 다른 해시값)
- 매우 느린 알고리즘 (무차별 대입 공격 방어)

### 3.3 HTTP-only 쿠키

#### XSS 공격 방어
```java
ResponseCookie refreshTokenCookie = ResponseCookie
    .from("refreshToken", token)
    .httpOnly(true)   // ⭐ JavaScript 접근 불가
    .secure(true)     // HTTPS에서만 전송 (프로덕션)
    .path("/")
    .maxAge(7 * 24 * 60 * 60)
    .sameSite("Lax")  // CSRF 방어
    .domain("localhost")
    .build();
```

**왜 HTTP-only인가?**
- XSS 공격으로 JavaScript 코드가 삽입되어도 쿠키를 읽을 수 없음
- `document.cookie`로 접근 불가

### 3.4 SameSite 쿠키 속성

#### CSRF 공격 방어
```java
.sameSite("Lax")  // 추천
```

**SameSite 옵션:**
| 값 | 설명 | 사용 예 |
|---|---|---|
| `Strict` | 외부 사이트에서 온 요청에 쿠키 전송 안 함 | 매우 민감한 정보 |
| `Lax` | GET 요청에는 쿠키 전송, POST는 안 함 | **일반적인 웹사이트 (권장)** |
| `None` | 모든 요청에 쿠키 전송 (Secure 필수) | 제3자 쿠키 필요 시 |

**Lax를 선택한 이유:**
- CSRF 공격 방어 (악의적인 사이트에서 POST 요청 시 쿠키 전송 안 됨)
- 일반적인 웹 사용 가능 (다른 사이트 링크 클릭 시 로그인 상태 유지)

### 3.5 CORS (Cross-Origin Resource Sharing)

#### 개발 환경 설정
```yaml
app:
  cors:
    allowed-origins:
      - http://localhost:5173  # Vite 개발 서버
      - http://localhost:3000  # React 개발 서버
    allowed-methods:
      - GET
      - POST
      - PUT
      - DELETE
      - OPTIONS
    allow-credentials: true  # 쿠키 전송 허용
```

**주의사항:**
- 프로덕션에서는 실제 도메인만 허용
- `allow-credentials: true` 사용 시 `allowedOrigins`에 와일드카드(`*`) 사용 불가

### 3.6 계정 상태 관리

#### User 엔티티의 상태 필드
```java
public enum Status {
    ACTIVE,                   // 활성 (정상)
    DELETED,                  // 삭제됨
    INACTIVE,                 // 비활성
    PENDING_VERIFICATION,     // 이메일 인증 대기
    SUSPENDED                 // 정지됨
}

private Boolean isActive;      // 활성화 여부
private Integer failedLoginAttempts;  // 로그인 실패 횟수
private LocalDateTime accountLockedUntil;  // 계정 잠금 시간
```

**보안 강화:**
- 로그인 실패 5회 이상 시 계정 잠금 (구현 예정)
- 비활성 계정 로그인 차단
- 삭제/정지 계정 로그인 차단

### 3.7 예외 처리

#### GlobalExceptionHandler로 일관된 에러 응답
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(InvalidCredentialsException.class)
    public ResponseEntity<ApiResponse<Void>> handleInvalidCredentials(...) {
        return ResponseEntity
            .status(HttpStatus.UNAUTHORIZED)
            .body(ApiResponse.error("이메일 또는 비밀번호가 올바르지 않습니다."));
    }
}
```

**처리하는 예외:**
- 400 Bad Request: 잘못된 입력값
- 401 Unauthorized: 인증 실패
- 403 Forbidden: 권한 없음
- 405 Method Not Allowed: 지원하지 않는 HTTP 메서드
- 415 Unsupported Media Type: 잘못된 Content-Type
- 500 Internal Server Error: 서버 오류

---

## 4. 기술 스택

### Backend
- **Spring Boot**: 4.0.0
- **Java**: 17
- **Spring Security**: 6.x
- **JPA/Hibernate**: 데이터베이스 ORM
- **MySQL**: 8.x
- **JWT**: io.jsonwebtoken (jjwt) 0.12.6
- **Lombok**: 코드 간소화

### 라이브러리
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'com.mysql:mysql-connector-j'
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
    implementation 'io.jsonwebtoken:jjwt-impl:0.12.6'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.12.6'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
}
```

---

## 5. 단계별 구현 가이드

### 1단계: 프로젝트 기본 설정

#### 1.1 application.yaml 설정
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/myauth?useSSL=false&serverTimezone=Asia/Seoul
    username: root
    password: yourpassword
  jpa:
    hibernate:
      ddl-auto: update  # 개발: update, 프로덕션: validate
    show-sql: true

# JWT 설정
jwt:
  secret: your-256-bit-secret-key-here-make-it-very-long-and-random
  access-token-expiration: 3600000    # 1시간 (밀리초)
  refresh-token-expiration: 604800000 # 7일 (밀리초)

# CORS 설정
app:
  cors:
    allowed-origins:
      - http://localhost:5173
    allowed-methods:
      - GET
      - POST
      - PUT
      - DELETE
      - OPTIONS
    allow-credentials: true

  # 쿠키 보안 설정
  cookie:
    secure: false  # 개발: false, 프로덕션: true (HTTPS 필요)
```

#### 1.2 JWT Secret Key 생성
```bash
# 안전한 256비트 키 생성
openssl rand -base64 32
```

---

### 2단계: 데이터베이스 설계

#### 2.1 User 엔티티 (`entity/User.java`)
```java
@Entity
@Table(name = "users")
@Getter @Setter @Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 100)
    private String email;

    @Column(nullable = false, length = 255)
    private String name;

    @Column(length = 255)  // OAuth 로그인 시 불필요
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @ColumnDefault("'ROLE_USER'")
    @Builder.Default
    private Role role = Role.ROLE_USER;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @ColumnDefault("'ACTIVE'")
    @Builder.Default
    private Status status = Status.ACTIVE;

    @Column(name = "is_active", nullable = false)
    @ColumnDefault("1")
    @Builder.Default
    private Boolean isActive = true;

    // OAuth 관련 필드
    @Column(length = 20)
    @ColumnDefault("'LOCAL'")
    @Builder.Default
    private String provider = "LOCAL";  // LOCAL, KAKAO, GOOGLE

    @Column(name = "provider_id", length = 100)
    private String providerId;  // 카카오 회원번호 등

    @Column(name = "profile_image", length = 500)
    private String profileImage;

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    public enum Role {
        ROLE_ADMIN,
        ROLE_USER
    }

    public enum Status {
        ACTIVE,
        DELETED,
        INACTIVE,
        PENDING_VERIFICATION,
        SUSPENDED
    }
}
```

#### 2.2 RefreshToken 엔티티 (`entity/RefreshToken.java`)
```java
@Entity
@Table(name = "refresh_tokens")
@Getter @Setter @Builder
@NoArgsConstructor
@AllArgsConstructor
public class RefreshToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 500)
    private String token;  // JWT Refresh Token 문자열

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @Column(name = "expires_at", nullable = false)
    private LocalDateTime expiresAt;

    @Column(name = "is_revoked", nullable = false)
    @Builder.Default
    private Boolean isRevoked = false;

    @Column(name = "last_used_at")
    private LocalDateTime lastUsedAt;

    // 비즈니스 메서드
    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiresAt);
    }

    public boolean isValid() {
        return !isRevoked && !isExpired();
    }

    public void revoke() {
        this.isRevoked = true;
    }

    public void updateLastUsedAt() {
        this.lastUsedAt = LocalDateTime.now();
    }
}
```

#### 2.3 Repository 인터페이스
```java
// repository/UserRepository.java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    Optional<User> findByProviderAndProviderId(String provider, String providerId);
}

// repository/RefreshTokenRepository.java
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Long> {
    Optional<RefreshToken> findByToken(String token);
    void deleteByToken(String token);
    void deleteAllByUser(User user);
}
```

---

### 3단계: JWT 토큰 관리 구현

#### 3.1 JwtTokenProvider (`security/JwtTokenProvider.java`)
```java
@Slf4j
@Component
public class JwtTokenProvider {

    private final SecretKey secretKey;
    private final long accessTokenExpiration;
    private final long refreshTokenExpiration;

    public JwtTokenProvider(
        @Value("${jwt.secret}") String secret,
        @Value("${jwt.access-token-expiration}") long accessTokenExpiration,
        @Value("${jwt.refresh-token-expiration}") long refreshTokenExpiration
    ) {
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
        this.accessTokenExpiration = accessTokenExpiration;
        this.refreshTokenExpiration = refreshTokenExpiration;
    }

    /**
     * Access Token 생성
     */
    public String generateAccessToken(String userEmail, Long userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + accessTokenExpiration);

        return Jwts.builder()
            .subject(userEmail)                 // 사용자 이메일
            .claim("userId", userId)            // 사용자 ID
            .claim("type", "access")            // 토큰 타입
            .issuedAt(now)                      // 발행 시간
            .expiration(expiryDate)             // 만료 시간
            .signWith(secretKey)                // 서명
            .compact();
    }

    /**
     * Refresh Token 생성
     */
    public String generateRefreshToken(String userEmail) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + refreshTokenExpiration);

        return Jwts.builder()
            .subject(userEmail)
            .claim("type", "refresh")
            .issuedAt(now)
            .expiration(expiryDate)
            .signWith(secretKey)
            .compact();
    }

    /**
     * 토큰에서 사용자 이메일 추출
     */
    public String getEmailFromToken(String token) {
        Claims claims = parseToken(token);
        return claims.getSubject();
    }

    /**
     * 토큰에서 사용자 ID 추출
     */
    public Long getUserIdFromToken(String token) {
        Claims claims = parseToken(token);
        return claims.get("userId", Long.class);
    }

    /**
     * 토큰 유효성 검증
     * @throws ExpiredJwtException 토큰 만료
     * @throws JwtException 토큰 서명 오류, 형식 오류 등
     */
    public boolean validateToken(String token) {
        parseToken(token);  // 예외 발생 시 자동 전파
        return true;
    }

    /**
     * 토큰 파싱 (내부 메서드)
     */
    private Claims parseToken(String token) {
        return Jwts.parser()
            .verifyWith(secretKey)
            .build()
            .parseSignedClaims(token)
            .getPayload();
    }

    /**
     * Refresh Token의 만료 시간 계산
     */
    public Date getRefreshTokenExpiryDate() {
        return new Date(System.currentTimeMillis() + refreshTokenExpiration);
    }
}
```

**핵심 포인트:**
- `Jwts.builder()`: JWT 생성
- `Jwts.parser()`: JWT 파싱 및 검증
- HS512 알고리즘 사용 (HMAC + SHA-512)
- Secret Key는 256비트 이상 권장

---

### 4단계: Spring Security 설정

#### 4.1 SecurityConfig (`config/SecurityConfig.java`)
```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(
        AuthenticationConfiguration config
    ) throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // CSRF 비활성화 (JWT 사용)
            .csrf(AbstractHttpConfigurer::disable)

            // 폼 로그인, HTTP Basic 비활성화
            .formLogin(AbstractHttpConfigurer::disable)
            .httpBasic(AbstractHttpConfigurer::disable)

            // 세션 사용 안 함 (Stateless)
            .sessionManagement(sm ->
                sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )

            // 경로별 인증 규칙
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/health", "/signup", "/login", "/loginEx", "/refresh")
                .permitAll()
                .requestMatchers("/auth/kakao/**").permitAll()
                .anyRequest().authenticated()
            )

            // 예외 처리
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint((request, response, authException) -> {
                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                    response.setContentType("application/json;charset=UTF-8");
                    response.getWriter().write(
                        "{\"error\":\"Unauthorized\",\"message\":\"인증이 필요합니다.\"}"
                    );
                })
            )

            // JWT 필터 추가
            .addFilterBefore(jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}
```

#### 4.2 JwtAuthenticationFilter (`security/JwtAuthenticationFilter.java`)
```java
@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider jwtTokenProvider;
    private final CustomUserDetailsService customUserDetailsService;

    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) throws ServletException, IOException {

        try {
            // 1. Authorization 헤더에서 JWT 추출
            String token = getJwtFromRequest(request);

            // 2. 토큰이 있고 유효하면
            if (token != null && jwtTokenProvider.validateToken(token)) {
                String email = jwtTokenProvider.getEmailFromToken(token);

                // 3. 사용자 정보 로드
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(email);

                // 4. Authentication 객체 생성
                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails,
                        null,
                        userDetails.getAuthorities()
                    );

                // 5. SecurityContext에 저장
                SecurityContextHolder.getContext().setAuthentication(authentication);

                log.debug("JWT 인증 성공: {}", email);
            }

        } catch (ExpiredJwtException e) {
            log.warn("만료된 JWT 토큰");
        } catch (JwtException e) {
            log.warn("유효하지 않은 JWT 토큰: {}", e.getMessage());
        } catch (Exception e) {
            log.error("JWT 인증 중 오류 발생", e);
        }

        filterChain.doFilter(request, response);
    }

    /**
     * Authorization 헤더에서 Bearer 토큰 추출
     */
    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

#### 4.3 CustomUserDetailsService (`security/CustomUserDetailsService.java`)
```java
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
            .orElseThrow(() -> new UsernameNotFoundException("사용자를 찾을 수 없습니다: " + email));

        return new CustomUserDetails(user);
    }
}
```

#### 4.4 CustomUserDetails (`security/CustomUserDetails.java`)
```java
@Getter
@RequiredArgsConstructor
public class CustomUserDetails implements UserDetails {

    private final User user;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return Collections.singletonList(
            new SimpleGrantedAuthority(user.getRole().name())
        );
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getEmail();
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return user.getAccountLockedUntil() == null ||
               user.getAccountLockedUntil().isBefore(LocalDateTime.now());
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    public boolean isEnabled() {
        return user.getIsActive() && user.getStatus() == User.Status.ACTIVE;
    }
}
```

---

### 5단계: 회원가입 구현

#### 5.1 SignupRequest DTO (`dto/SignupRequest.java`)
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class SignupRequest {
    @NotBlank(message = "이메일을 입력해주세요")
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;

    @NotBlank(message = "비밀번호를 입력해주세요")
    @Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다")
    private String password;

    @NotBlank(message = "사용자 이름을 입력해주세요")
    private String username;
}
```

#### 5.2 AuthService - 회원가입 로직 (`service/AuthService.java`)
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class AuthService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtTokenProvider jwtTokenProvider;
    private final RefreshTokenRepository refreshTokenRepository;

    /**
     * 회원가입 처리
     */
    @Transactional
    public void registerUser(SignupRequest signupRequest) {
        // 1. 이메일 정규화 (공백 제거, 소문자 변환)
        String normalizedEmail = signupRequest.getEmail().trim().toLowerCase();

        try {
            // 2. User 엔티티 생성
            User user = User.builder()
                .email(normalizedEmail)
                .password(passwordEncoder.encode(signupRequest.getPassword()))
                .name(signupRequest.getUsername())
                .role(User.Role.ROLE_USER)
                .status(User.Status.ACTIVE)
                .isActive(true)
                .build();

            // 3. DB에 저장 (unique constraint 위반 시 예외 발생)
            userRepository.save(user);
            log.info("회원 가입 성공: {}", user.getEmail());

        } catch (DataIntegrityViolationException e) {
            // 4. 중복 이메일 처리
            log.warn("중복된 이메일로 가입 시도: {}", normalizedEmail);
            throw new DuplicateEmailException("이미 가입된 이메일입니다.");
        }
    }
}
```

#### 5.3 AuthController - 회원가입 엔드포인트 (`controller/AuthController.java`)
```java
@RestController
@RequiredArgsConstructor
@Slf4j
public class AuthController {
    private final AuthService authService;

    /**
     * 회원가입
     * POST /signup
     */
    @PostMapping("/signup")
    public ResponseEntity<ApiResponse<Void>> signup(
        @Valid @RequestBody SignupRequest signupRequest
    ) {
        log.info("회원가입 요청: {}", signupRequest.getEmail());

        authService.registerUser(signupRequest);

        return ResponseEntity
            .status(HttpStatus.CREATED)
            .body(ApiResponse.success("회원가입이 완료되었습니다."));
    }
}
```

#### 5.4 예외 클래스 (`exception/DuplicateEmailException.java`)
```java
public class DuplicateEmailException extends RuntimeException {
    public DuplicateEmailException(String message) {
        super(message);
    }
}
```

#### 5.5 GlobalExceptionHandler (`exception/GlobalExceptionHandler.java`)
```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 이메일 중복 예외 처리
     */
    @ExceptionHandler(DuplicateEmailException.class)
    public ResponseEntity<ApiResponse<Void>> handleDuplicateEmail(
        DuplicateEmailException ex
    ) {
        log.warn("이메일 중복: {}", ex.getMessage());

        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error(ex.getMessage()));
    }

    /**
     * Bean Validation 검증 실패 처리
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationExceptions(
        MethodArgumentNotValidException ex
    ) {
        String errorMessage = ex.getBindingResult()
            .getAllErrors()
            .stream()
            .findFirst()
            .map(ObjectError::getDefaultMessage)
            .orElse("입력값이 올바르지 않습니다.");

        log.warn("입력값 검증 실패: {}", errorMessage);

        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ApiResponse.error(errorMessage));
    }
}
```

#### 5.6 ApiResponse DTO (`dto/ApiResponse.java`)
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ApiResponse<T> {
    private Boolean success;
    private String message;
    private T data;

    public static <T> ApiResponse<T> success(String message) {
        return new ApiResponse<>(true, message, null);
    }

    public static <T> ApiResponse<T> success(String message, T data) {
        return new ApiResponse<>(true, message, data);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, message, null);
    }
}
```

---

### 6단계: 일반 로그인 구현

#### 6.1 LoginRequest DTO (`dto/LoginRequest.java`)
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    @NotBlank(message = "이메일을 입력해주세요")
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;

    @NotBlank(message = "비밀번호를 입력해주세요")
    @Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다")
    private String password;
}
```

#### 6.2 LoginResponse DTO (`dto/LoginResponse.java`)
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginResponse {
    private String accessToken;
    private String refreshToken;
    private UserInfo user;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class UserInfo {
        private Long id;
        private String email;
        private String name;
        private String role;
    }
}
```

#### 6.3 방법 1: 수동 검증 방식 (교육용)

**AuthService.java:**
```java
/**
 * 로그인 처리 (수동 검증 방식)
 */
@Transactional
public LoginResponse login(@Valid LoginRequest loginRequest) {
    // 1. 이메일 정규화
    String normalizedEmail = loginRequest.getEmail().trim().toLowerCase();
    log.info("로그인 시도: {}", normalizedEmail);

    // 2. 사용자 조회
    User user = userRepository.findByEmail(normalizedEmail)
        .orElseThrow(() -> {
            log.warn("존재하지 않는 이메일로 로그인 시도: {}", normalizedEmail);
            return new InvalidCredentialsException("이메일 또는 비밀번호가 올바르지 않습니다.");
        });

    // 3. 비밀번호 검증
    boolean isPasswordValid = passwordEncoder.matches(
        loginRequest.getPassword(),  // 입력된 평문 비밀번호
        user.getPassword()            // DB에 저장된 암호화된 비밀번호
    );

    if (!isPasswordValid) {
        log.warn("잘못된 비밀번호로 로그인 시도: {}", normalizedEmail);
        throw new InvalidCredentialsException("이메일 또는 비밀번호가 올바르지 않습니다.");
    }

    // 4. 계정 상태 확인
    if (!user.getIsActive()) {
        throw new AccountException("비활성화된 계정입니다.");
    }

    if (user.getStatus() != User.Status.ACTIVE) {
        String errorMessage = switch (user.getStatus()) {
            case SUSPENDED -> "정지된 계정입니다.";
            case DELETED -> "삭제된 계정입니다.";
            case INACTIVE -> "비활성화된 계정입니다.";
            case PENDING_VERIFICATION -> "이메일 인증이 필요합니다.";
            default -> "로그인할 수 없는 계정 상태입니다.";
        };
        throw new AccountException(errorMessage);
    }

    // 5. JWT 토큰 생성
    String accessToken = jwtTokenProvider.generateAccessToken(user.getEmail(), user.getId());
    String refreshToken = jwtTokenProvider.generateRefreshToken(user.getEmail());

    // 6. Refresh Token DB 저장
    RefreshToken refreshTokenEntity = RefreshToken.builder()
        .token(refreshToken)
        .user(user)
        .expiresAt(LocalDateTime.ofInstant(
            jwtTokenProvider.getRefreshTokenExpiryDate().toInstant(),
            ZoneId.systemDefault()
        ))
        .build();

    refreshTokenRepository.save(refreshTokenEntity);
    log.info("Refresh Token DB 저장 완료: {}", normalizedEmail);

    // 7. 로그인 성공 응답 반환
    LoginResponse.UserInfo userInfo = LoginResponse.UserInfo.builder()
        .id(user.getId())
        .email(user.getEmail())
        .name(user.getName())
        .role(user.getRole().name())
        .build();

    return LoginResponse.builder()
        .accessToken(accessToken)
        .refreshToken(refreshToken)
        .user(userInfo)
        .build();
}
```

**AuthController.java:**
```java
/**
 * 로그인 (수동 검증 방식)
 * POST /login
 */
@PostMapping("/login")
public ResponseEntity<ApiResponse<LoginResponse>> login(
    @Valid @RequestBody LoginRequest loginRequest
) {
    log.info("로그인 요청: {}", loginRequest.getEmail());

    LoginResponse loginResponse = authService.login(loginRequest);

    return ResponseEntity.ok(
        ApiResponse.success("로그인 성공", loginResponse)
    );
}
```

#### 6.4 방법 2: AuthenticationManager 사용 (권장)

**AuthService.java:**
```java
private final AuthenticationManager authenticationManager;

/**
 * 로그인 처리 (AuthenticationManager 사용 - 권장)
 */
@Transactional
public LoginResponse loginEx(@Valid LoginRequest loginRequest) {
    // 1. 이메일 정규화
    String normalizedEmail = loginRequest.getEmail().trim().toLowerCase();
    log.info("로그인 시도 (loginEx): {}", normalizedEmail);

    // 2. AuthenticationManager를 통해 인증 처리
    // Spring Security가 자동으로:
    // - CustomUserDetailsService를 통해 사용자 조회
    // - PasswordEncoder를 통해 비밀번호 검증
    // - UserDetails의 계정 상태 확인
    Authentication authentication;
    try {
        authentication = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(
                normalizedEmail,
                loginRequest.getPassword()
            )
        );
    } catch (AuthenticationException e) {
        log.warn("로그인 실패 (loginEx): {} - {}", normalizedEmail, e.getMessage());
        throw new InvalidCredentialsException("이메일 또는 비밀번호가 올바르지 않습니다.");
    }

    // 3. 인증 성공 시 User 엔티티 추출
    CustomUserDetails customUserDetails = (CustomUserDetails) authentication.getPrincipal();
    User user = customUserDetails.getUser();

    // 4. JWT 토큰 생성 (이하 동일)
    String accessToken = jwtTokenProvider.generateAccessToken(user.getEmail(), user.getId());
    String refreshToken = jwtTokenProvider.generateRefreshToken(user.getEmail());

    // 5. Refresh Token DB 저장
    RefreshToken refreshTokenEntity = RefreshToken.builder()
        .token(refreshToken)
        .user(user)
        .expiresAt(LocalDateTime.ofInstant(
            jwtTokenProvider.getRefreshTokenExpiryDate().toInstant(),
            ZoneId.systemDefault()
        ))
        .build();

    refreshTokenRepository.save(refreshTokenEntity);

    // 6. 응답 생성
    LoginResponse.UserInfo userInfo = LoginResponse.UserInfo.builder()
        .id(user.getId())
        .email(user.getEmail())
        .name(user.getName())
        .role(user.getRole().name())
        .build();

    return LoginResponse.builder()
        .accessToken(accessToken)
        .refreshToken(refreshToken)
        .user(userInfo)
        .build();
}
```

**AuthController.java (하이브리드 방식 - 웹/모바일 구분):**
```java
/**
 * 로그인 (하이브리드 방식 - 웹/모바일 구분)
 * POST /loginEx
 */
@PostMapping("/loginEx")
public ResponseEntity<ApiResponse<LoginResponse>> loginEx(
    @Valid @RequestBody LoginRequest loginRequest,
    HttpServletRequest request,
    HttpServletResponse response
) {
    log.info("로그인 요청 (loginEx): {}", loginRequest.getEmail());

    // 1. 클라이언트 타입 감지 (User-Agent 기반)
    boolean isWebClient = ClientTypeDetector.isWebClient(request);

    // 2. 로그인 처리
    LoginResponse loginResponse = authService.loginEx(loginRequest);

    // 3. 웹 클라이언트면 Refresh Token을 HTTP-only 쿠키로 설정
    if (isWebClient) {
        ResponseCookie refreshTokenCookie = ResponseCookie
            .from("refreshToken", loginResponse.getRefreshToken())
            .httpOnly(true)   // JavaScript 접근 불가 (XSS 방어)
            .secure(appProperties.getCookie().isSecure())  // 환경별 설정
            .path("/")
            .maxAge(7 * 24 * 60 * 60)  // 7일
            .sameSite("Lax")  // CSRF 방어
            .domain("localhost")  // 포트 무관하게 localhost 전체 공유
            .build();

        response.addHeader(HttpHeaders.SET_COOKIE, refreshTokenCookie.toString());

        // 응답 바디에서 Refresh Token 제거 (보안 강화)
        loginResponse.setRefreshToken(null);
    }

    return ResponseEntity.ok(ApiResponse.success("로그인 성공", loginResponse));
}
```

**ClientTypeDetector 유틸리티 (`util/ClientTypeDetector.java`):**
```java
public class ClientTypeDetector {

    /**
     * User-Agent를 분석하여 웹 브라우저인지 판단
     */
    public static boolean isWebClient(HttpServletRequest request) {
        String userAgent = request.getHeader("User-Agent");
        if (userAgent == null) {
            return false;
        }

        // 웹 브라우저 User-Agent 패턴
        return userAgent.contains("Mozilla") ||
               userAgent.contains("Chrome") ||
               userAgent.contains("Safari") ||
               userAgent.contains("Firefox");
    }

    public static String getClientTypeString(HttpServletRequest request) {
        return isWebClient(request) ? "웹 브라우저" : "모바일 앱";
    }
}
```

#### 6.5 Access Token 갱신 구현

**TokenRefreshRequest DTO:**
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class TokenRefreshRequest {
    // @NotBlank 제거 (웹 클라이언트는 쿠키 사용)
    private String refreshToken;
}
```

**TokenRefreshResponse DTO:**
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TokenRefreshResponse {
    private String accessToken;
    private String refreshToken;  // Refresh Token Rotation 시 사용
}
```

**AuthService - refreshAccessToken:**
```java
/**
 * Refresh Token으로 Access Token 갱신
 */
@Transactional(readOnly = true)
public TokenRefreshResponse refreshAccessToken(String refreshToken) {
    log.info("Access Token 갱신 요청");

    // 1. Refresh Token JWT 검증
    if (!jwtTokenProvider.validateToken(refreshToken)) {
        throw new TokenException("유효하지 않은 Refresh Token입니다.");
    }

    // 2. Refresh Token에서 이메일 추출
    String email = jwtTokenProvider.getEmailFromToken(refreshToken);

    // 3. DB에 해당 Refresh Token이 존재하는지 확인
    RefreshToken refreshTokenEntity = refreshTokenRepository.findByToken(refreshToken)
        .orElseThrow(() -> new TokenException("유효하지 않은 Refresh Token입니다."));

    // 4. Refresh Token이 만료되었는지 확인
    if (refreshTokenEntity.getExpiresAt().isBefore(LocalDateTime.now())) {
        throw new TokenException("Refresh Token이 만료되었습니다. 다시 로그인해주세요.");
    }

    // 5. 사용자 조회 및 계정 상태 확인
    User user = refreshTokenEntity.getUser();
    if (user == null || !user.getIsActive() || user.getStatus() != User.Status.ACTIVE) {
        throw new AccountException("비활성화된 계정입니다.");
    }

    // 6. 새 Access Token 생성
    String newAccessToken = jwtTokenProvider.generateAccessToken(user.getEmail(), user.getId());

    return TokenRefreshResponse.builder()
        .accessToken(newAccessToken)
        .refreshToken(null)  // Refresh Token Rotation 미사용
        .build();
}
```

**AuthController - refresh:**
```java
/**
 * Access Token 갱신 (하이브리드 방식)
 * POST /refresh
 */
@PostMapping("/refresh")
public ResponseEntity<ApiResponse<TokenRefreshResponse>> refresh(
    HttpServletRequest request,
    @RequestBody(required = false) @Valid TokenRefreshRequest body
) {
    log.info("Access Token 갱신 요청");

    // 1. 클라이언트 타입 감지
    boolean isWebClient = ClientTypeDetector.isWebClient(request);

    // 2. 클라이언트 타입에 따라 Refresh Token 추출
    String refreshToken;
    if (isWebClient) {
        // 웹: 쿠키에서 읽기
        refreshToken = extractRefreshTokenFromCookies(request);
        if (refreshToken == null) {
            return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(ApiResponse.error("Refresh Token이 없습니다. 다시 로그인해주세요."));
        }
    } else {
        // 모바일: 요청 바디에서 읽기
        refreshToken = extractRefreshTokenFromBody(body);
        if (refreshToken == null) {
            return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body(ApiResponse.error("Refresh Token은 필수입니다."));
        }
    }

    // 3. Refresh Token으로 새 Access Token 발급
    TokenRefreshResponse refreshResponse = authService.refreshAccessToken(refreshToken);

    return ResponseEntity.ok(
        ApiResponse.success("Access Token이 갱신되었습니다", refreshResponse)
    );
}

/**
 * HTTP 쿠키에서 Refresh Token 추출
 */
private String extractRefreshTokenFromCookies(HttpServletRequest request) {
    Cookie[] cookies = request.getCookies();
    if (cookies == null) return null;

    for (Cookie cookie : cookies) {
        if ("refreshToken".equals(cookie.getName())) {
            return cookie.getValue();
        }
    }
    return null;
}

/**
 * 요청 바디에서 Refresh Token 추출
 */
private String extractRefreshTokenFromBody(TokenRefreshRequest body) {
    if (body == null || body.getRefreshToken() == null ||
        body.getRefreshToken().isBlank()) {
        return null;
    }
    return body.getRefreshToken();
}
```

---

### 7단계: 카카오 OAuth 로그인 구현

#### 7.1 카카오 개발자 콘솔 설정

1. https://developers.kakao.com/ 접속
2. 애플리케이션 생성
3. **앱 설정 > 앱 키** 복사:
   - REST API 키 (Client ID)
   - Client Secret 발급
4. **제품 설정 > 카카오 로그인**:
   - Redirect URI 등록: `http://localhost:9080/auth/kakao/callback`
   - 동의 항목 설정: **이메일을 필수 동의**로 설정

#### 7.2 application.yaml 설정
```yaml
kakao:
  oauth:
    client-id: your-kakao-rest-api-key
    client-secret: your-kakao-client-secret
    redirect-uri: http://localhost:9080/auth/kakao/callback
    authorization-uri: https://kauth.kakao.com/oauth/authorize
    token-uri: https://kauth.kakao.com/oauth/token
    user-info-uri: https://kapi.kakao.com/v2/user/me
```

#### 7.3 KakaoOAuthProperties (`config/KakaoOAuthProperties.java`)
```java
@Getter
@Setter
@Component
@ConfigurationProperties(prefix = "kakao.oauth")
public class KakaoOAuthProperties {
    private String clientId;
    private String clientSecret;
    private String redirectUri;
    private String authorizationUri;
    private String tokenUri;
    private String userInfoUri;
}
```

#### 7.4 KakaoOAuthDto (`dto/kakao/KakaoOAuthDto.java`)
```java
public class KakaoOAuthDto {

    /**
     * 카카오 토큰 응답 DTO
     */
    @Data
    @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
    public static class TokenResponse {
        private String tokenType;
        private String accessToken;
        private Integer expiresIn;
        private String refreshToken;
        private Integer refreshTokenExpiresIn;
    }

    /**
     * 카카오 사용자 정보 응답 DTO
     */
    @Data
    @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
    public static class UserInfoResponse {
        private Long id;  // 카카오 회원번호
        private KakaoAccount kakaoAccount;

        @Data
        @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
        public static class KakaoAccount {
            private String email;
            private Profile profile;

            @Data
            @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy.class)
            public static class Profile {
                private String nickname;
                private String profileImageUrl;
            }
        }
    }
}
```

#### 7.5 KakaoOAuthService (`service/KakaoOAuthService.java`)
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class KakaoOAuthService {

    private final KakaoOAuthProperties kakaoProperties;
    private final UserRepository userRepository;
    private final RefreshTokenRepository refreshTokenRepository;
    private final JwtTokenProvider jwtTokenProvider;
    private final RestClient restClient = RestClient.create();

    /**
     * 1단계: 카카오 인가 코드 요청 URL 생성
     */
    public String getAuthorizationUrl() {
        return UriComponentsBuilder
            .fromUriString(kakaoProperties.getAuthorizationUri())
            .queryParam("client_id", kakaoProperties.getClientId())
            .queryParam("redirect_uri", kakaoProperties.getRedirectUri())
            .queryParam("response_type", "code")
            .build()
            .toUriString();
    }

    /**
     * 2단계: Authorization Code로 카카오 Access Token 요청
     */
    public KakaoOAuthDto.TokenResponse getAccessToken(String code) {
        log.info("카카오 Access Token 요청 - code: {}", code);

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("grant_type", "authorization_code");
        params.add("client_id", kakaoProperties.getClientId());
        params.add("client_secret", kakaoProperties.getClientSecret());
        params.add("redirect_uri", kakaoProperties.getRedirectUri());
        params.add("code", code);

        return restClient.post()
            .uri(kakaoProperties.getTokenUri())
            .contentType(MediaType.APPLICATION_FORM_URLENCODED)
            .body(params)
            .retrieve()
            .body(KakaoOAuthDto.TokenResponse.class);
    }

    /**
     * 3단계: 카카오 Access Token으로 사용자 정보 조회
     */
    public KakaoOAuthDto.UserInfoResponse getUserInfo(String accessToken) {
        log.info("카카오 사용자 정보 조회");

        return restClient.get()
            .uri(kakaoProperties.getUserInfoUri())
            .header("Authorization", "Bearer " + accessToken)
            .retrieve()
            .body(KakaoOAuthDto.UserInfoResponse.class);
    }

    /**
     * 4단계: 카카오 사용자 정보로 로그인 처리
     * 기존 회원이면 로그인, 신규 회원이면 자동 회원가입 후 로그인
     */
    @Transactional
    public LoginResponse processKakaoLogin(KakaoOAuthDto.UserInfoResponse kakaoUserInfo) {
        String providerId = String.valueOf(kakaoUserInfo.getId());
        String email = kakaoUserInfo.getKakaoAccount().getEmail();
        String nickname = kakaoUserInfo.getKakaoAccount().getProfile().getNickname();
        String profileImage = kakaoUserInfo.getKakaoAccount().getProfile().getProfileImageUrl();

        // 이메일 필수 검증
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException(
                "카카오 계정의 이메일 정보가 필요합니다. 카카오 로그인 시 이메일 제공에 동의해주세요."
            );
        }

        // 1. 카카오 ID로 기존 회원 조회
        Optional<User> existingUser = userRepository.findByProviderAndProviderId("KAKAO", providerId);

        User user;
        if (existingUser.isPresent()) {
            // 기존 회원 - 프로필 업데이트
            user = existingUser.get();
            user.setName(nickname);
            user.setProfileImage(profileImage);
            userRepository.save(user);
            log.info("기존 카카오 회원 로그인: {}", user.getEmail());

        } else {
            // 신규 회원 - 자동 회원가입
            user = User.builder()
                .email(email)
                .name(nickname)
                .password(null)  // OAuth 로그인은 비밀번호 불필요
                .provider("KAKAO")
                .providerId(providerId)
                .profileImage(profileImage)
                .role(User.Role.ROLE_USER)
                .status(User.Status.ACTIVE)
                .isActive(true)
                .build();

            userRepository.save(user);
            log.info("신규 카카오 회원 가입 완료: {}", user.getEmail());
        }

        // 2. JWT 토큰 생성
        String accessToken = jwtTokenProvider.generateAccessToken(user.getEmail(), user.getId());
        String refreshToken = jwtTokenProvider.generateRefreshToken(user.getEmail());

        // 3. Refresh Token DB 저장
        RefreshToken refreshTokenEntity = RefreshToken.builder()
            .token(refreshToken)
            .user(user)
            .expiresAt(LocalDateTime.ofInstant(
                jwtTokenProvider.getRefreshTokenExpiryDate().toInstant(),
                ZoneId.systemDefault()
            ))
            .build();

        refreshTokenRepository.save(refreshTokenEntity);

        // 4. 로그인 응답 생성
        LoginResponse.UserInfo userInfo = LoginResponse.UserInfo.builder()
            .id(user.getId())
            .email(user.getEmail())
            .name(user.getName())
            .role(user.getRole().name())
            .build();

        return LoginResponse.builder()
            .accessToken(accessToken)
            .refreshToken(refreshToken)
            .user(userInfo)
            .build();
    }
}
```

#### 7.6 KakaoAuthController (`controller/KakaoAuthController.java`)
```java
@Slf4j
@RestController
@RequestMapping("/auth/kakao")
@RequiredArgsConstructor
public class KakaoAuthController {

    private final KakaoOAuthService kakaoOAuthService;
    private final AppProperties appProperties;

    /**
     * 카카오 로그인 시작
     * GET /auth/kakao/login?redirectUrl=프론트엔드_콜백_URL
     */
    @GetMapping("/login")
    public void kakaoLogin(
        @RequestParam(required = false) String redirectUrl,
        HttpSession session,
        HttpServletResponse response
    ) throws IOException {
        log.info("카카오 로그인 요청");

        // 프론트엔드 redirectUrl을 세션에 저장
        if (redirectUrl != null && !redirectUrl.isBlank()) {
            session.setAttribute("kakaoRedirectUrl", redirectUrl);
        }

        // 카카오 인가 페이지로 리다이렉트
        String authorizationUrl = kakaoOAuthService.getAuthorizationUrl();
        response.sendRedirect(authorizationUrl);
    }

    /**
     * 카카오 로그인 콜백 처리
     * GET /auth/kakao/callback?code=AUTHORIZATION_CODE
     */
    @GetMapping("/callback")
    public void kakaoCallback(
        @RequestParam String code,
        HttpServletRequest request,
        HttpServletResponse response
    ) throws IOException {
        log.info("카카오 로그인 콜백 - code: {}", code);

        try {
            // 1. Authorization Code로 카카오 Access Token 요청
            KakaoOAuthDto.TokenResponse tokenResponse = kakaoOAuthService.getAccessToken(code);

            // 2. 카카오 Access Token으로 사용자 정보 조회
            KakaoOAuthDto.UserInfoResponse kakaoUserInfo =
                kakaoOAuthService.getUserInfo(tokenResponse.getAccessToken());

            // 3. 카카오 사용자 정보로 로그인 처리
            LoginResponse loginResponse = kakaoOAuthService.processKakaoLogin(kakaoUserInfo);

            // 4. 웹 클라이언트 감지
            boolean isWebClient = ClientTypeDetector.isWebClient(request);

            if (isWebClient) {
                // 웹: 세션에 토큰 저장 후 프론트엔드로 리다이렉트
                HttpSession session = request.getSession(true);
                session.setAttribute("pendingLoginResponse", loginResponse);

                // 프론트엔드 redirectUrl (세션에서 복원)
                String frontendRedirectUrl = (String) session.getAttribute("kakaoRedirectUrl");
                if (frontendRedirectUrl == null) {
                    frontendRedirectUrl = appProperties.getOauth().getKakaoRedirectUrl();
                }
                session.removeAttribute("kakaoRedirectUrl");

                String successRedirectUrl = frontendRedirectUrl + "?status=success";
                response.sendRedirect(successRedirectUrl);

            } else {
                // 모바일: JSON 응답 반환
                response.setContentType("application/json");
                response.setCharacterEncoding("UTF-8");

                String jsonResponse = String.format(
                    "{\"success\":true,\"message\":\"카카오 로그인 성공\"," +
                    "\"data\":{\"accessToken\":\"%s\",\"refreshToken\":\"%s\"," +
                    "\"user\":{\"id\":%d,\"email\":\"%s\",\"name\":\"%s\"}}}",
                    loginResponse.getAccessToken(),
                    loginResponse.getRefreshToken(),
                    loginResponse.getUser().getId(),
                    loginResponse.getUser().getEmail(),
                    loginResponse.getUser().getName()
                );
                response.getWriter().write(jsonResponse);
            }

        } catch (Exception e) {
            log.error("카카오 로그인 실패: {}", e.getMessage(), e);

            String errorRedirectUrl = appProperties.getOauth().getKakaoRedirectUrl();
            String finalErrorRedirectUrl = String.format(
                "%s?error=%s",
                errorRedirectUrl,
                java.net.URLEncoder.encode(e.getMessage(), "UTF-8")
            );
            response.sendRedirect(finalErrorRedirectUrl);
        }
    }

    /**
     * 토큰 교환 엔드포인트 (웹 전용)
     * POST /auth/kakao/exchange-token
     */
    @PostMapping("/exchange-token")
    public ResponseEntity<ApiResponse<LoginResponse>> exchangeToken(
        HttpServletRequest request,
        HttpServletResponse response
    ) {
        // 세션에서 대기 중인 LoginResponse 가져오기
        HttpSession session = request.getSession(false);
        if (session == null) {
            return ResponseEntity
                .status(401)
                .body(ApiResponse.error("세션이 만료되었습니다."));
        }

        LoginResponse loginResponse = (LoginResponse) session.getAttribute("pendingLoginResponse");
        if (loginResponse == null) {
            return ResponseEntity
                .status(401)
                .body(ApiResponse.error("로그인 정보가 없습니다."));
        }

        // 세션에서 제거 (일회용)
        session.removeAttribute("pendingLoginResponse");

        // Refresh Token을 HTTP-only 쿠키로 설정
        ResponseCookie refreshTokenCookie = ResponseCookie
            .from("refreshToken", loginResponse.getRefreshToken())
            .httpOnly(true)
            .secure(appProperties.getCookie().isSecure())
            .path("/")
            .maxAge(7 * 24 * 60 * 60)
            .sameSite("Lax")
            .domain("localhost")
            .build();

        response.addHeader(HttpHeaders.SET_COOKIE, refreshTokenCookie.toString());

        // 응답 바디에서 Refresh Token 제거
        loginResponse.setRefreshToken(null);

        return ResponseEntity.ok(ApiResponse.success("토큰 교환 성공", loginResponse));
    }
}
```

**핵심 포인트:**
- **Cross-Port 쿠키 문제**: OAuth 콜백은 localhost:9080에서 처리되지만, 프론트엔드는 localhost:5173에서 실행
- **해결 방법**:
  1. 콜백에서 토큰을 세션에 임시 저장
  2. 프론트엔드가 `/exchange-token`을 Vite 프록시를 통해 호출
  3. Vite 프록시를 통한 요청이므로 쿠키가 정상 작동

---

### 8단계: 로그아웃 구현

#### 8.1 CustomLogoutHandler (`security/CustomLogoutHandler.java`)
```java
@Slf4j
@Component
@RequiredArgsConstructor
public class CustomLogoutHandler implements LogoutHandler {

    private final RefreshTokenRepository refreshTokenRepository;

    @Override
    public void logout(
        HttpServletRequest request,
        HttpServletResponse response,
        Authentication authentication
    ) {
        log.info("로그아웃 처리 시작");

        // 1. 쿠키에서 Refresh Token 추출
        String refreshToken = extractRefreshTokenFromCookies(request);

        // 2. 요청 바디에서 Refresh Token 추출 (모바일 앱용)
        if (refreshToken == null) {
            refreshToken = extractRefreshTokenFromBody(request);
        }

        // 3. Refresh Token이 있으면 DB에서 삭제
        if (refreshToken != null) {
            try {
                refreshTokenRepository.deleteByToken(refreshToken);
                log.info("Refresh Token DB에서 삭제 완료");
            } catch (Exception e) {
                log.error("Refresh Token 삭제 실패: {}", e.getMessage());
            }
        }

        log.info("로그아웃 처리 완료");
    }

    private String extractRefreshTokenFromCookies(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies == null) return null;

        for (Cookie cookie : cookies) {
            if ("refreshToken".equals(cookie.getName())) {
                return cookie.getValue();
            }
        }
        return null;
    }

    private String extractRefreshTokenFromBody(HttpServletRequest request) {
        try {
            String body = request.getReader().lines()
                .collect(Collectors.joining(System.lineSeparator()));

            // JSON 파싱 (간단한 예)
            if (body.contains("refreshToken")) {
                // 실제로는 ObjectMapper 사용 권장
                return extractJsonValue(body, "refreshToken");
            }
        } catch (Exception e) {
            log.warn("요청 바디 읽기 실패: {}", e.getMessage());
        }
        return null;
    }

    private String extractJsonValue(String json, String key) {
        // 간단한 JSON 파싱 (실제로는 ObjectMapper 사용 권장)
        String searchKey = "\"" + key + "\":\"";
        int startIndex = json.indexOf(searchKey);
        if (startIndex == -1) return null;

        startIndex += searchKey.length();
        int endIndex = json.indexOf("\"", startIndex);

        return endIndex > startIndex ? json.substring(startIndex, endIndex) : null;
    }
}
```

#### 8.2 CustomLogoutSuccessHandler (`security/CustomLogoutSuccessHandler.java`)
```java
@Slf4j
@Component
@RequiredArgsConstructor
public class CustomLogoutSuccessHandler implements LogoutSuccessHandler {

    private final AppProperties appProperties;

    @Override
    public void onLogoutSuccess(
        HttpServletRequest request,
        HttpServletResponse response,
        Authentication authentication
    ) throws IOException {
        log.info("로그아웃 성공");

        // 1. Refresh Token 쿠키 삭제 (웹 클라이언트)
        ResponseCookie deleteCookie = ResponseCookie
            .from("refreshToken", "")
            .httpOnly(true)
            .secure(appProperties.getCookie().isSecure())
            .path("/")
            .maxAge(0)  // 즉시 만료
            .sameSite("Lax")
            .domain("localhost")
            .build();

        response.addHeader(HttpHeaders.SET_COOKIE, deleteCookie.toString());

        // 2. JSON 응답 반환
        response.setStatus(HttpServletResponse.SC_OK);
        response.setContentType("application/json;charset=UTF-8");
        response.getWriter().write(
            "{\"success\":true,\"message\":\"로그아웃되었습니다.\"}"
        );
    }
}
```

#### 8.3 SecurityConfig에 로그아웃 설정 추가
```java
.logout(logout -> logout
    .logoutUrl("/logout")  // 로그아웃 URL
    .addLogoutHandler(customLogoutHandler)
    .logoutSuccessHandler(customLogoutSuccessHandler)
    .permitAll()
)
```

---

### 9단계: 예외 처리 강화

#### GlobalExceptionHandler에 추가 핸들러 구현

```java
/**
 * HTTP 요청 body 읽기 실패 시 처리
 */
@ExceptionHandler(HttpMessageNotReadableException.class)
public ResponseEntity<ApiResponse<Void>> handleHttpMessageNotReadable(
    HttpMessageNotReadableException ex
) {
    String errorMessage;
    String detailMessage = ex.getMessage();

    if (detailMessage != null && detailMessage.contains("Required request body is missing")) {
        errorMessage = "요청 body가 비어있습니다. JSON 형식의 데이터를 전송해주세요.";
    } else {
        errorMessage = "잘못된 요청 형식입니다. JSON 형식이 올바른지 확인해주세요.";
    }

    log.warn("HTTP 메시지 읽기 실패: {}", errorMessage);

    return ResponseEntity
        .status(HttpStatus.BAD_REQUEST)
        .body(ApiResponse.error(errorMessage));
}

/**
 * 지원하지 않는 Content-Type
 */
@ExceptionHandler(HttpMediaTypeNotSupportedException.class)
public ResponseEntity<ApiResponse<Void>> handleHttpMediaTypeNotSupported(
    HttpMediaTypeNotSupportedException ex
) {
    String errorMessage =
        "지원하지 않는 Content-Type입니다. 'Content-Type: application/json' 헤더를 추가해주세요.";

    return ResponseEntity
        .status(HttpStatus.UNSUPPORTED_MEDIA_TYPE)
        .body(ApiResponse.error(errorMessage));
}

/**
 * 지원하지 않는 HTTP 메서드
 */
@ExceptionHandler(HttpRequestMethodNotSupportedException.class)
public ResponseEntity<ApiResponse<Void>> handleHttpRequestMethodNotSupported(
    HttpRequestMethodNotSupportedException ex
) {
    String supportedMethods = ex.getSupportedHttpMethods() != null
        ? ex.getSupportedHttpMethods().toString()
        : "지원되는 메서드 없음";

    String errorMessage = String.format(
        "%s 메서드는 지원하지 않습니다. 지원하는 메서드: %s",
        ex.getMethod(),
        supportedMethods
    );

    return ResponseEntity
        .status(HttpStatus.METHOD_NOT_ALLOWED)
        .body(ApiResponse.error(errorMessage));
}

/**
 * 모든 예외를 처리하는 최후의 방어선
 */
@ExceptionHandler(Exception.class)
public ResponseEntity<ApiResponse<Void>> handleAllExceptions(Exception ex) {
    log.error("예상치 못한 오류 발생: {}", ex.getMessage(), ex);

    return ResponseEntity
        .status(HttpStatus.INTERNAL_SERVER_ERROR)
        .body(ApiResponse.error("서버 오류가 발생했습니다. 잠시 후 다시 시도해주세요."));
}
```

---

## 6. API 엔드포인트 정리

### 인증 불필요 (Public)

| Method | Endpoint | 설명 | Request Body | Response |
|--------|----------|------|--------------|----------|
| GET | `/health` | 서버 상태 확인 | - | `{"success":true,"message":"Auth Service is running"}` |
| POST | `/signup` | 회원가입 | `SignupRequest` | `{"success":true,"message":"회원가입이 완료되었습니다."}` |
| POST | `/login` | 로그인 (수동 검증) | `LoginRequest` | `{"success":true,"message":"로그인 성공","data":LoginResponse}` |
| POST | `/loginEx` | 로그인 (권장) | `LoginRequest` | 동일 |
| POST | `/refresh` | Access Token 갱신 | `TokenRefreshRequest` (모바일) 또는 쿠키 (웹) | `{"success":true,"message":"Access Token이 갱신되었습니다","data":TokenRefreshResponse}` |
| POST | `/logout` | 로그아웃 | - | `{"success":true,"message":"로그아웃되었습니다."}` |
| GET | `/auth/kakao/login` | 카카오 로그인 시작 | - | 카카오 로그인 페이지로 리다이렉트 |
| GET | `/auth/kakao/callback` | 카카오 로그인 콜백 | `?code=xxx` | 프론트엔드로 리다이렉트 (웹) 또는 JSON (모바일) |
| POST | `/auth/kakao/exchange-token` | 토큰 교환 (웹 전용) | - | `{"success":true,"data":LoginResponse}` |

### 인증 필요 (Protected)

| Method | Endpoint | 설명 | Request Header | Response |
|--------|----------|------|----------------|----------|
| GET | `/user/me` | 내 정보 조회 | `Authorization: Bearer <AccessToken>` | `{"success":true,"data":UserResponse}` |

---

## 7. 테스트 방법

### 7.1 회원가입 테스트

```bash
curl -X POST http://localhost:9080/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "username": "테스트유저"
  }'
```

**성공 응답 (201 Created):**
```json
{
  "success": true,
  "message": "회원가입이 완료되었습니다.",
  "data": null
}
```

**실패 응답 (400 Bad Request):**
```json
{
  "success": false,
  "message": "이미 가입된 이메일입니다.",
  "data": null
}
```

### 7.2 로그인 테스트

```bash
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'
```

**성공 응답 (200 OK):**
```json
{
  "success": true,
  "message": "로그인 성공",
  "data": {
    "accessToken": "eyJhbGciOiJIUzUxMiJ9...",
    "refreshToken": "eyJhbGciOiJIUzUxMiJ9...",
    "user": {
      "id": 1,
      "email": "test@example.com",
      "name": "테스트유저",
      "role": "ROLE_USER"
    }
  }
}
```

### 7.3 인증된 API 호출 테스트

```bash
# Access Token을 환경 변수에 저장
TOKEN="eyJhbGciOiJIUzUxMiJ9..."

# 내 정보 조회
curl -X GET http://localhost:9080/user/me \
  -H "Authorization: Bearer $TOKEN"
```

**성공 응답 (200 OK):**
```json
{
  "success": true,
  "message": "사용자 정보 조회 성공",
  "data": {
    "id": 1,
    "email": "test@example.com",
    "name": "테스트유저",
    "role": "ROLE_USER"
  }
}
```

**실패 응답 (401 Unauthorized):**
```json
{
  "error": "Unauthorized",
  "message": "인증이 필요합니다."
}
```

### 7.4 Access Token 갱신 테스트

#### 모바일 앱
```bash
REFRESH_TOKEN="eyJhbGciOiJIUzUxMiJ9..."

curl -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -d "{\"refreshToken\":\"$REFRESH_TOKEN\"}"
```

#### 웹 브라우저 (쿠키 사용)
```bash
curl -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -H "Cookie: refreshToken=$REFRESH_TOKEN"
```

**성공 응답 (200 OK):**
```json
{
  "success": true,
  "message": "Access Token이 갱신되었습니다",
  "data": {
    "accessToken": "eyJhbGciOiJIUzUxMiJ9...",
    "refreshToken": null
  }
}
```

### 7.5 로그아웃 테스트

```bash
curl -X POST http://localhost:9080/logout \
  -H "Cookie: refreshToken=$REFRESH_TOKEN"
```

**성공 응답 (200 OK):**
```json
{
  "success": true,
  "message": "로그아웃되었습니다."
}
```

### 7.6 카카오 로그인 테스트

1. 브라우저에서 접속:
   ```
   http://localhost:9080/auth/kakao/login?redirectUrl=http://localhost:5173/oauth/callback
   ```

2. 카카오 로그인 페이지에서 로그인

3. 콜백 처리 후 프론트엔드로 리다이렉트:
   ```
   http://localhost:5173/oauth/callback?status=success
   ```

4. 프론트엔드에서 토큰 교환 API 호출:
   ```javascript
   fetch('http://localhost:9080/auth/kakao/exchange-token', {
     method: 'POST',
     credentials: 'include'  // 쿠키 전송
   })
   ```

### 7.7 에러 케이스 테스트

#### 빈 body로 요청
```bash
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json"
```

**응답 (400 Bad Request):**
```json
{
  "success": false,
  "message": "요청 body가 비어있습니다. JSON 형식의 데이터를 전송해주세요.",
  "data": null
}
```

#### 잘못된 Content-Type
```bash
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "email=test@example.com&password=123"
```

**응답 (415 Unsupported Media Type):**
```json
{
  "success": false,
  "message": "지원하지 않는 Content-Type입니다. 'Content-Type: application/json' 헤더를 추가해주세요.",
  "data": null
}
```

#### 지원하지 않는 HTTP 메서드
```bash
curl -X GET http://localhost:9080/loginEx
```

**응답 (405 Method Not Allowed):**
```json
{
  "success": false,
  "message": "GET 메서드는 지원하지 않습니다. 지원하는 메서드: [POST]",
  "data": null
}
```

---

## 8. 프론트엔드 연동 예시

### 8.1 Axios 인터셉터 설정 (React/Vue/Angular 공통)

```javascript
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:9080',
  withCredentials: true  // 쿠키 전송 허용
});

// Access Token 저장 (메모리 또는 로컬 스토리지)
let accessToken = null;

// 요청 인터셉터: 모든 요청에 Access Token 추가
api.interceptors.request.use(
  (config) => {
    if (accessToken) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// 응답 인터셉터: 401 에러 시 토큰 갱신
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    // 401 에러이고, 재시도하지 않은 요청인 경우
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // Refresh Token으로 Access Token 갱신 (쿠키 자동 전송)
        const { data } = await axios.post(
          'http://localhost:9080/refresh',
          {},
          { withCredentials: true }
        );

        // 새 Access Token 저장
        accessToken = data.data.accessToken;

        // 원래 요청 재시도
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return api(originalRequest);

      } catch (refreshError) {
        // Refresh Token도 만료됨 → 로그인 페이지로 리다이렉트
        accessToken = null;
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

// 로그인 함수
export async function login(email, password) {
  const { data } = await api.post('/loginEx', { email, password });
  accessToken = data.data.accessToken;  // Access Token 저장
  // Refresh Token은 HTTP-only 쿠키에 자동 저장됨
  return data;
}

// 로그아웃 함수
export async function logout() {
  await api.post('/logout');
  accessToken = null;
}

export default api;
```

### 8.2 카카오 로그인 연동 (React 예시)

```javascript
// 카카오 로그인 버튼 클릭
function handleKakaoLogin() {
  const frontendCallbackUrl = 'http://localhost:5173/oauth/callback';
  window.location.href = `http://localhost:9080/auth/kakao/login?redirectUrl=${frontendCallbackUrl}`;
}

// OAuth 콜백 페이지 (/oauth/callback)
import { useEffect } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import axios from 'axios';

function OAuthCallbackPage() {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();

  useEffect(() => {
    const status = searchParams.get('status');
    const error = searchParams.get('error');

    if (status === 'success') {
      // 토큰 교환 API 호출
      axios.post('http://localhost:9080/auth/kakao/exchange-token', {}, {
        withCredentials: true  // 세션 쿠키 전송
      })
        .then((response) => {
          // Access Token 저장
          const { accessToken, user } = response.data.data;
          localStorage.setItem('accessToken', accessToken);
          localStorage.setItem('user', JSON.stringify(user));

          // 메인 페이지로 이동
          navigate('/');
        })
        .catch((err) => {
          console.error('토큰 교환 실패:', err);
          navigate('/login');
        });

    } else if (error) {
      alert('카카오 로그인 실패: ' + error);
      navigate('/login');
    }
  }, [searchParams, navigate]);

  return <div>로그인 처리 중...</div>;
}

export default OAuthCallbackPage;
```

---

## 9. 보안 체크리스트

### 개발 환경
- [x] JWT Secret Key는 256비트 이상
- [x] Access Token 만료 시간 짧게 설정 (1시간)
- [x] Refresh Token 만료 시간 길게 설정 (7일)
- [x] HTTP-only 쿠키 사용 (웹)
- [x] SameSite=Lax 설정 (CSRF 방어)
- [x] 비밀번호 BCrypt 암호화
- [x] 이메일 정규화 (소문자 변환)
- [x] 입력값 검증 (Bean Validation)
- [x] 예외 처리 (GlobalExceptionHandler)
- [x] CORS 설정 (허용된 출처만)
- [x] 로그인 실패 시 동일한 에러 메시지 (정보 유출 방지)

### 프로덕션 환경 추가 설정
- [ ] HTTPS 사용 (Secure 쿠키 true)
- [ ] JWT Secret Key 환경 변수로 분리
- [ ] DB 비밀번호 환경 변수로 분리
- [ ] CORS 허용 출처를 실제 도메인으로 제한
- [ ] Rate Limiting (로그인 시도 제한)
- [ ] 계정 잠금 정책 (로그인 5회 실패 시)
- [ ] IP 기반 접근 제한 (선택)
- [ ] 로그 모니터링 (비정상 로그인 감지)
- [ ] Refresh Token Rotation (보안 강화)

---

## 10. 다음 단계

### 추가 구현 권장 기능
1. **이메일 인증**: 회원가입 시 이메일 인증 링크 발송
2. **비밀번호 재설정**: 이메일로 임시 비밀번호 또는 재설정 링크 발송
3. **2FA (이중 인증)**: OTP 또는 SMS 인증
4. **소셜 로그인 확장**: 구글, 네이버, 애플 로그인 추가
5. **계정 잠금 정책**: 로그인 실패 5회 시 계정 잠금
6. **Refresh Token Rotation**: 토큰 갱신 시 새 Refresh Token 발급
7. **IP 기반 접근 제어**: 특정 IP만 접근 허용
8. **감사 로그**: 로그인/로그아웃 이력 저장

---

## 11. 참고 자료

### 공식 문서
- [Spring Security 공식 문서](https://docs.spring.io/spring-security/reference/index.html)
- [JWT.io](https://jwt.io/) - JWT 디버거 및 문서
- [JJWT GitHub](https://github.com/jwtk/jjwt) - Java JWT 라이브러리
- [카카오 로그인 가이드](https://developers.kakao.com/docs/latest/ko/kakaologin/common)

### 보안 관련
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP Cheat Sheet Series - Authentication](https://cheatsheetseries.owasp.org/cheatsheets/Authentication_Cheat_Sheet.html)
- [RFC 7519 - JWT](https://datatracker.ietf.org/doc/html/rfc7519)
- [RFC 6749 - OAuth 2.0](https://datatracker.ietf.org/doc/html/rfc6749)

---

## 12. 문제 해결 (Troubleshooting)

### 문제 1: JWT 서명 오류
```
io.jsonwebtoken.security.SignatureException: JWT signature does not match
```

**원인**: Secret Key가 다르거나 토큰이 변조됨

**해결**:
1. application.yaml의 `jwt.secret` 확인
2. 토큰 생성과 검증에 동일한 Secret Key 사용 확인

### 문제 2: Access Token 만료
```
io.jsonwebtoken.ExpiredJwtException: JWT expired at ...
```

**원인**: Access Token 만료 (정상 동작)

**해결**:
- 프론트엔드에서 `/refresh` API 호출하여 새 Access Token 발급

### 문제 3: CORS 에러
```
Access to XMLHttpRequest at 'http://localhost:9080/login' from origin 'http://localhost:5173'
has been blocked by CORS policy
```

**원인**: CORS 설정 미흡

**해결**:
```yaml
app:
  cors:
    allowed-origins:
      - http://localhost:5173  # 프론트엔드 주소 추가
    allow-credentials: true
```

### 문제 4: 쿠키가 전송되지 않음
**원인**:
- `withCredentials: true` 미설정 (프론트엔드)
- `allow-credentials: true` 미설정 (백엔드)
- `Secure` 쿠키인데 HTTP 사용

**해결**:
1. 프론트엔드: `axios.defaults.withCredentials = true`
2. 백엔드: `app.cors.allow-credentials: true`
3. 개발 환경: `app.cookie.secure: false`

### 문제 5: 카카오 로그인 시 이메일이 null
**원인**: 카카오 개발자 콘솔에서 이메일 동의 항목 설정 안 함

**해결**:
1. https://developers.kakao.com/ 접속
2. 앱 선택 → 카카오 로그인 → 동의 항목
3. 이메일을 **필수 동의**로 설정

---

## 마무리

이 가이드를 따라 구현하면 **안전하고 확장 가능한 JWT 기반 인증 시스템**을 구축할 수 있습니다.

핵심 요약:
- ✅ JWT (Access + Refresh Token)
- ✅ Spring Security + BCrypt
- ✅ HTTP-only 쿠키 (XSS 방어)
- ✅ SameSite=Lax (CSRF 방어)
- ✅ 하이브리드 토큰 전송 (웹/모바일)
- ✅ 카카오 OAuth 2.0 소셜 로그인
- ✅ 전역 예외 처리

**프로덕션 배포 전 반드시 체크:**
- HTTPS 적용
- Secret Key 환경 변수화
- CORS 설정 엄격화
- Rate Limiting 적용
- 모니터링 설정

---

**작성일**: 2025-12-20
**버전**: 1.0
**작성자**: Claude Code (AI 어시스턴트)
