# API 테스트 가이드

## 1. Health Check
curl http://localhost:9080/health

## 2. 회원가입
curl -X POST http://localhost:9080/signup \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "username": "테스트유저"
  }'

## 3. 로그인 (토큰 획득)
curl -X POST http://localhost:9080/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'

## 4. 로그인 후 accessToken만 추출
TOKEN=$(curl -s -X POST http://localhost:9080/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }' | jq -r '.accessToken')

echo "토큰: $TOKEN"

## 5. /me 엔드포인트 호출 (인증 필요)

### 5-1. 토큰 없이 호출 (실패 - 403 Forbidden)
curl -w "\nHTTP Status: %{http_code}\n" http://localhost:9080/me

### 5-2. 토큰과 함께 호출 (성공)
# 먼저 로그인해서 토큰 획득
TOKEN=$(curl -s -X POST http://localhost:9080/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }' | jq -r '.accessToken')

# 토큰과 함께 /me 호출
curl -H "Authorization: Bearer $TOKEN" http://localhost:9080/me | jq .

### 5-3. 한 줄로 실행 (로그인 + /me 호출)
curl -H "Authorization: Bearer $(curl -s -X POST http://localhost:9080/login -H 'Content-Type: application/json' -d '{\"email\":\"test@example.com\",\"password\":\"password123\"}' | jq -r '.accessToken')" http://localhost:9080/me | jq .

## 응답 예시

### 성공 응답
{
  "success": true,
  "message": "사용자 정보 조회 성공",
  "data": {
    "id": 40,
    "email": "test@example.com",
    "name": "테스트유저",
    "role": "ROLE_USER",
    "isActive": true
  }
}

### 실패 응답 (토큰 없음)
HTTP Status: 403

## 6. 로그인 (하이브리드 방식 - 웹/모바일 구분)

### 6-1. 웹 클라이언트로 로그인 (기본값)
# User-Agent 헤더가 없거나 일반 브라우저인 경우
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' \
  -c cookies.txt \
  -v

# 결과: Refresh Token이 HTTP-only 쿠키로 설정됨
# 응답 바디에는 accessToken과 userInfo만 포함 (refreshToken은 null)

### 6-2. 웹 클라이언트임을 명시적으로 지정
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: web" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' \
  -c cookies.txt \
  -v

### 6-3. 모바일 클라이언트로 로그인 (커스텀 헤더 사용)
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' | jq .

# 결과: 쿠키 없음, 응답 바디에 accessToken과 refreshToken 모두 포함

### 6-4. 모바일 클라이언트로 로그인 (User-Agent 시뮬레이션)
# Android OkHttp
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "User-Agent: okhttp/4.9.0" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' | jq .

# iOS CFNetwork
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "User-Agent: MyApp/1.0 CFNetwork/1240.0.4 Darwin/20.6.0" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' | jq .

# React Native
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "User-Agent: MyApp/1.0 (React Native)" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' | jq .

### 6-5. 쿠키를 사용하여 API 요청 (웹 클라이언트)
# 먼저 웹 방식으로 로그인하여 쿠키 저장
curl -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' \
  -c cookies.txt

# Access Token 추출
TOKEN=$(curl -s -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test2@example.com",
    "password": "password123"
  }' | jq -r '.accessToken')

# 쿠키와 함께 /me 호출
curl -H "Authorization: Bearer $TOKEN" \
  -b cookies.txt \
  http://localhost:9080/me | jq .

### 6-6. 로그 확인
# 로그인 시 서버 로그에서 클라이언트 타입 감지 결과 확인
tail -f logs/myauth.log | grep "클라이언트 타입"

## 7. loginEx 응답 예시

### 웹 클라이언트 응답 (Refresh Token이 쿠키로 전송됨)
{
  "success": true,
  "message": "로그인 성공",
  "accessToken": "eyJhbGciOiJIUzUxMiJ9...",
  "refreshToken": null,  # ← 쿠키로 전송되므로 null
  "userInfo": {
    "id": 40,
    "email": "test2@example.com",
    "name": "테스트유저2",
    "role": "ROLE_USER"
  }
}

### 모바일 클라이언트 응답 (모든 토큰이 JSON에 포함)
{
  "success": true,
  "message": "로그인 성공",
  "accessToken": "eyJhbGciOiJIUzUxMiJ9...",
  "refreshToken": "eyJhbGciOiJIUzUxMiJ9...",  # ← JSON에 포함
  "userInfo": {
    "id": 40,
    "email": "test2@example.com",
    "name": "테스트유저2",
    "role": "ROLE_USER"
  }
}

## 8. Access Token 갱신 (Refresh)

### 8-1. 웹 클라이언트 - 쿠키에서 Refresh Token 읽기
# 먼저 loginEx로 로그인하여 쿠키 저장
curl -s -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -d '{"email":"test2@example.com","password":"password123"}' \
  -c /tmp/cookies.txt

# 쿠키와 함께 /refresh 호출
curl -s -X POST http://localhost:9080/refresh \
  -b /tmp/cookies.txt | jq .

# 결과: 새로운 Access Token 발급됨

### 8-2. 모바일 클라이언트 - 요청 바디에 Refresh Token 포함
# 먼저 loginEx로 로그인 (모바일)
REFRESH_TOKEN=$(curl -s -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d '{"email":"test2@example.com","password":"password123"}' \
  | jq -r '.refreshToken')

echo "Refresh Token: $REFRESH_TOKEN"

# Refresh Token으로 새 Access Token 발급
curl -s -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d "{\"refreshToken\":\"$REFRESH_TOKEN\"}" | jq .

### 8-3. 한 줄로 실행 (모바일 - 로그인 + 토큰 갱신)
curl -s -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d "{\"refreshToken\":\"$(curl -s -X POST http://localhost:9080/loginEx -H 'Content-Type: application/json' -H 'X-Client-Type: mobile-app' -d '{\"email\":\"test2@example.com\",\"password\":\"password123\"}' | jq -r '.refreshToken')\"}" | jq .

### 8-4. Access Token 만료 후 갱신 테스트
# 1. 로그인하여 토큰 저장
curl -s -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d '{"email":"test2@example.com","password":"password123"}' > /tmp/login_response.json

# Access Token과 Refresh Token 추출
ACCESS_TOKEN=$(cat /tmp/login_response.json | jq -r '.accessToken')
REFRESH_TOKEN=$(cat /tmp/login_response.json | jq -r '.refreshToken')

echo "Access Token: $ACCESS_TOKEN"
echo "Refresh Token: $REFRESH_TOKEN"

# 2. Access Token으로 /me 호출 (성공)
curl -s -H "Authorization: Bearer $ACCESS_TOKEN" http://localhost:9080/me | jq .

# 3. (Access Token 만료 후) Refresh Token으로 새 Access Token 발급
NEW_ACCESS_TOKEN=$(curl -s -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d "{\"refreshToken\":\"$REFRESH_TOKEN\"}" | jq -r '.accessToken')

echo "New Access Token: $NEW_ACCESS_TOKEN"

# 4. 새 Access Token으로 /me 호출 (성공)
curl -s -H "Authorization: Bearer $NEW_ACCESS_TOKEN" http://localhost:9080/me | jq .

### 8-5. 잘못된 Refresh Token으로 갱신 시도 (실패)
curl -s -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d '{"refreshToken":"invalid_token_12345"}' | jq .

# 결과: 401 Unauthorized + "유효하지 않은 Refresh Token입니다"

### 8-6. Refresh Token 없이 갱신 시도 (실패)
# 웹 클라이언트인데 쿠키가 없는 경우
curl -s -X POST http://localhost:9080/refresh | jq .

# 모바일 클라이언트인데 요청 바디가 없는 경우
curl -s -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" | jq .

## 9. Refresh 응답 예시

### 성공 응답
{
  "success": true,
  "message": "Access Token이 갱신되었습니다",
  "accessToken": "eyJhbGciOiJIUzUxMiJ9...",  # ← 새로 발급된 Access Token
  "refreshToken": null  # Refresh Token Rotation 미사용
}

### 실패 응답 (유효하지 않은 Refresh Token)
{
  "success": false,
  "message": "유효하지 않은 Refresh Token입니다. 다시 로그인해주세요.",
  "accessToken": null,
  "refreshToken": null
}

### 실패 응답 (만료된 Refresh Token)
{
  "success": false,
  "message": "Refresh Token이 만료되었습니다. 다시 로그인해주세요.",
  "accessToken": null,
  "refreshToken": null
}

## 10. Access Token 만료 에러 처리 테스트

### 10-1. 토큰 만료 에러 응답 확인
# Access Token이 만료되면 401 Unauthorized와 함께 상세한 에러 정보가 반환됩니다
# 클라이언트는 errorCode를 확인하여 자동으로 /refresh를 호출할 수 있습니다

# 먼저 로그인하여 토큰 획득
ACCESS_TOKEN=$(curl -s -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d '{"email":"test2@example.com","password":"password123"}' \
  | jq -r '.accessToken')

echo "Access Token: $ACCESS_TOKEN"

# 토큰으로 /me 호출 (성공)
curl -s -H "Authorization: Bearer $ACCESS_TOKEN" http://localhost:9080/me | jq .

# 1시간 후 토큰이 만료되면 다음과 같은 응답을 받게 됩니다:
# HTTP Status: 401 Unauthorized
# {
#   "errorCode": "TOKEN_EXPIRED",
#   "message": "Access Token이 만료되었습니다. 토큰을 갱신해주세요.",
#   "action": "REFRESH_TOKEN",
#   "path": "/me"
# }

### 10-2. 유효하지 않은 토큰 에러 응답 확인
# 잘못된 서명, 형식 오류 등의 경우 다른 에러 코드가 반환됩니다

curl -s -H "Authorization: Bearer invalid_token_12345" \
  http://localhost:9080/me | jq .

# 응답:
# HTTP Status: 401 Unauthorized
# {
#   "errorCode": "INVALID_TOKEN",
#   "message": "유효하지 않은 토큰입니다. 다시 로그인해주세요.",
#   "action": "LOGIN_REQUIRED",
#   "path": "/me"
# }

### 10-3. 토큰 없이 호출 시 에러 응답
# Authorization 헤더가 없으면 403 Forbidden (Spring Security 기본 동작)
curl -w "\nHTTP Status: %{http_code}\n" http://localhost:9080/me

# 응답: HTTP Status: 403 Forbidden
# (Spring Security가 인증되지 않은 요청을 차단)

### 10-4. 클라이언트 측 자동 토큰 갱신 시뮬레이션
# 실제 클라이언트에서는 401 + TOKEN_EXPIRED 응답을 받으면
# 자동으로 /refresh를 호출하고 재시도합니다

# 1단계: 로그인 및 토큰 저장
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:9080/loginEx \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d '{"email":"test2@example.com","password":"password123"}')

ACCESS_TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.accessToken')
REFRESH_TOKEN=$(echo "$LOGIN_RESPONSE" | jq -r '.refreshToken')

echo "Initial Access Token: $ACCESS_TOKEN"
echo "Refresh Token: $REFRESH_TOKEN"

# 2단계: /me 호출 (성공)
echo -e "\n=== /me 호출 (성공) ==="
curl -s -H "Authorization: Bearer $ACCESS_TOKEN" http://localhost:9080/me | jq .

# 3단계: (Access Token 만료 시뮬레이션 - 실제로는 1시간 후)
# 만료된 토큰으로 /me 호출 시 401 + TOKEN_EXPIRED 응답

# 4단계: errorCode가 TOKEN_EXPIRED이면 자동으로 /refresh 호출
echo -e "\n=== Access Token 갱신 ==="
NEW_ACCESS_TOKEN=$(curl -s -X POST http://localhost:9080/refresh \
  -H "Content-Type: application/json" \
  -H "X-Client-Type: mobile-app" \
  -d "{\"refreshToken\":\"$REFRESH_TOKEN\"}" \
  | jq -r '.accessToken')

echo "New Access Token: $NEW_ACCESS_TOKEN"

# 5단계: 새 Access Token으로 /me 재시도 (성공)
echo -e "\n=== 새 토큰으로 /me 재시도 (성공) ==="
curl -s -H "Authorization: Bearer $NEW_ACCESS_TOKEN" http://localhost:9080/me | jq .

### 10-5. 에러 코드별 클라이언트 처리 로직 (참고)
# JavaScript/TypeScript 클라이언트 예시:
#
# axios.interceptors.response.use(
#   response => response,
#   async error => {
#     const originalRequest = error.config;
#
#     // 401 응답이고 errorCode가 TOKEN_EXPIRED인 경우
#     if (error.response?.status === 401 &&
#         error.response?.data?.errorCode === 'TOKEN_EXPIRED') {
#
#       try {
#         // /refresh 호출하여 새 Access Token 획득
#         const refreshToken = localStorage.getItem('refreshToken');
#         const { data } = await axios.post('/refresh', { refreshToken });
#
#         // 새 토큰 저장
#         localStorage.setItem('accessToken', data.accessToken);
#
#         // 원래 요청 재시도
#         originalRequest.headers.Authorization = `Bearer ${data.accessToken}`;
#         return axios(originalRequest);
#       } catch (refreshError) {
#         // Refresh Token도 만료되었으면 로그인 페이지로 이동
#         window.location.href = '/login';
#         return Promise.reject(refreshError);
#       }
#     }
#
#     // 401 응답이고 errorCode가 INVALID_TOKEN인 경우
#     if (error.response?.status === 401 &&
#         error.response?.data?.errorCode === 'INVALID_TOKEN') {
#       // 재로그인 필요
#       window.location.href = '/login';
#     }
#
#     return Promise.reject(error);
#   }
# );

## 11. 에러 응답 정리

### 토큰 만료 (TOKEN_EXPIRED)
{
  "errorCode": "TOKEN_EXPIRED",
  "message": "Access Token이 만료되었습니다. 토큰을 갱신해주세요.",
  "action": "REFRESH_TOKEN",
  "path": "/me"
}
# HTTP Status: 401 Unauthorized
# 클라이언트 액션: /refresh 엔드포인트 자동 호출

### 유효하지 않은 토큰 (INVALID_TOKEN)
{
  "errorCode": "INVALID_TOKEN",
  "message": "유효하지 않은 토큰입니다. 다시 로그인해주세요.",
  "action": "LOGIN_REQUIRED",
  "path": "/me"
}
# HTTP Status: 401 Unauthorized
# 클라이언트 액션: 재로그인 페이지로 이동

### 토큰 없음
# HTTP Status: 403 Forbidden
# Spring Security 기본 에러 응답
# 클라이언트 액션: 로그인 페이지로 이동
